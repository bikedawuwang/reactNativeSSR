// Library
import {
Injectable,
BadRequestException,
NotFoundException
} from '@nestjs/common';
import _ from 'lodash';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';

// Internal
import { {{pascalCase moduleName}}Model } from './{{moduleName}}.model';

@Injectable()
export class {{pascalCase moduleName}}Service {
private readonly {{pascalCase moduleName}}: {{pascalCase moduleName}}Model[] = [];

constructor(
@InjectRepository({{pascalCase moduleName}}Model)
private readonly {{pascalCase moduleName}}Repository: Repository<{{pascalCase moduleName}}Model>
    ) {}

    protected getId(paramId: any): number {
        const id = parseInt(paramId, 10);

        if (isNaN(id) || typeof id !== 'number') {
            throw new BadRequestException();
        }

        return id;
    }

    async create({{pascalCase moduleName}}Payload: {{pascalCase moduleName}}Model): Promise<{{pascalCase moduleName}}Model> {
        const {{pascalCase moduleName}} = new {{pascalCase moduleName}}Model();
        // -- Autogenerated Model Service Definition --

        return await this.{{pascalCase moduleName}}Repository.save({{pascalCase moduleName}});
    }

    async findAll(filters: any): Promise<{{pascalCase moduleName}}Model[]> {
        const params: any = {
            where: {},
            cache: filters.cache || true,
            order: { id: 'ASC' },
        };
        
        if (filters.where) {
            params.where = { ...filters.where };
        }
        
        if (filters.not) {
            _.map(filters.not, (val, key) => {
                params['where'][key] = Not(val)
            })
        }
        
        if (filters.like) {
            _.map(filters.like, (val, key) => {
                params['where'][key] = Like(val)
            })
        }
        
        if (filters.in) {
            _.map(filters.in, (val, key) => {
                params['where'][key] = In(val)
            })
        }
        
        if (filters.any) {
            _.map(filters.any, (val, key) => {
                params['where'][key] = Any(val)
            })
        }
        
        if (filters.order) {
            params.order = { ...filters.order };
        }
        
        if (filters.skip) {
            params.skip = filters.skip;
        }
        
        if (filters.take) {
            params.take = filters.take;
        }
        
        return await this.{{pascalCase moduleName}}Repository.find(params);
    }

    async findOneById(id: number): Promise<{{pascalCase moduleName}}Model> {
        return await this.{{pascalCase moduleName}}Repository.findOne(id, { cache: true });
    }

    async update(paramId: any, entity: {{pascalCase moduleName}}Model): Promise<{{pascalCase moduleName}}Model> {
        await this.{{pascalCase moduleName}}Repository.update(paramId, entity);
        return await this.findOneById(paramId);
    }

    async delete(paramId: any): Promise<void> {
        const id = this.getId(paramId);
        try {
            await this.{{pascalCase moduleName}}Repository.delete(id);
        } catch (err) {
            throw new NotFoundException();
        }
    }
}